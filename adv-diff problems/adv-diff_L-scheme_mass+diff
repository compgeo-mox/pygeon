import os
import shutil
import numpy as np
import porepy as pp
import pygeon as pg
import sympy as sp
import matplotlib.pyplot as plt


"""
Solve nonlinear advection-diffusion equation using Backward Euler in time,
linearized by the L-scheme, and discretized by Finite Element Method (FEM).

PDE:
    ∂_t B(u) + a · ∇u - ∇·( D(u) ∇u ) = S

Time discretization (Backward Euler):
    (B(u)^{n} - B(u)^{n-1}) / Δt + a · ∇u^{n} - ∇·( D(u^{n}) ∇u^{n} ) = S^{n}

L-scheme linearization at iteration i:
    B(u^{i}) - Δt ∇·( D(u^{i}) ∇u^{i} ) ≈ B(u^{i-1}) - ∇·( D(u^{i-1}) ∇u^{i} )
    + L (u^{i} - u^{i-1})

(NOT SURE)

Variational (weak) form at iteration i: find u^{(i)} in V such that
for all test functions φ:

    + Δt ∫_Ω (a · ∇u^{n,i}) φ dΩ
    + Δt ∫_Ω D(u^{n,i-1}) ∇u^{n,i} · ∇φ dΩ
    + L ∫_Ω u^{n,i} φ dΩ
    = Δt ∫_Ω S^{n,i} φ dΩ
    + Δt ∫_Γ D(u^{n,i-1}) (∇u^{n,i} · ν) φ dΓ
    + ∫_Ω B(u^{n-1}) φ dΩ
    - ∫_Ω B(u^{n,i-1)} φ dΩ
    + L ∫_Ω u^{n,i-1} φ dΩ

This gives the matrix equation:
    (Δt A + Δt D^{i-1} + L M)(u^{n+1}) = Δt F + Δt BC + M B(u^{n-1}) 
    - M B(u^{i-1}) + L M u^{i-1}

"""

# Paramenter
D = 1  # Diffusion coefficient
V = np.array([1.0, 0.0, 0.0])  # Velocity vector
L = 3e-2  # L-scheme parameter, can be adjusted
inflow_rate = 10.0  # Inflow rate for the boundary condition

grid_sizes = [[5, 5], [10, 10], [20, 20], [40, 40], [80, 80]]  # [[50, 50]]
dim = [1, 1]
timesteps = [0.001]  # [0.1, 0.05, 0.025, 0.0125, 0.00625]  # [0.0001]
end_time = 1
iter = 50  # Number of iterations for the L-scheme linearization
# Relative and absolute tolerances for the non-linear solver
abs_tol = 1e-7
rel_tol = 1e-7
linearization = "newton"  # Linearization method, can be "newton" or "l-scheme"

key = "mass"

l2_errors = []

P1 = pg.Lagrange1(key)


def manufactured_solution():
    """Manufactured solution for the advection-diffusion equation."""

    # Define variables and parameters
    x, y, t = sp.symbols("x y t")
    Vx, Vy = sp.symbols("Vx Vy")

    # Define manufactured solution u
    u = t * x * y

    B = 1 + u**2  # Nonlinear mass term B(u)
    D = 1 + u**2  # Nonlinear diffusion term D(u)

    # Compute partial derivatives
    Bt = sp.diff(B, t)
    ux = sp.diff(u, x)
    uy = sp.diff(u, y)
    Dx = sp.diff(D, x)
    Dy = sp.diff(D, y)

    # Advection term: divergence of V * u
    adv = sp.diff(Vx * u, x) + sp.diff(Vy * u, y)

    # Diffusion term
    diff = sp.diff(D * ux, x) + sp.diff(D * uy, y)

    # Source term f from PDE residual
    f = Bt + adv - diff

    # Set the velocity field values
    f = f.subs({Vx: 1.0, Vy: 0.0})

    # Simplify the source term
    f_simplified = sp.simplify(f)

    # Create lambdified functions for source term and solution
    source = sp.lambdify((x, y, t), f_simplified, "numpy")
    solution = sp.lambdify((x, y, t), u, "numpy")

    return source, solution


def nat_bc_func(x):
    """Natural boundary condition function."""
    return inflow_rate


def ess_bc_func(x):
    """Essential boundary condition function."""
    return 0.0


def source_term(x):
    """Source term function."""
    return 0.0


def init_sol_func(x):
    """Initial condition function."""
    return 0.0


def diff_func(sd, u):
    """Compute the non-linear diffusion term D(u) on grid."""
    return 1 + u**2


def vel_func(sd, u):
    """Compute the non-linear advection term A(u) on grid.
    Note: Not used"""
    return 1.0 * np.ones(sd.num_cells)


def mass_func(u):
    """Compute the non-linear mass term B(u) on grid."""
    return 1 + u**2


def create_grid(grid_size, dim):
    """Create a structured triangle grid for the problem."""
    sd = pp.StructuredTriangleGrid(grid_size, dim)

    # convert the grid into a mixed-dimensional grid
    mdg = pg.as_mdg(sd)

    # Convert to a pygeon grid
    pg.convert_from_pp(sd)
    sd.compute_geometry()

    return mdg


def export_data(name, sol, mdg, sd):
    """Export the solution data to pvd-file."""
    output_directory = os.path.join(os.path.dirname(__file__), "adv-diff " + name)
    # Delete the output directory, if it exisis
    if os.path.exists(output_directory):
        shutil.rmtree(output_directory)

    save = pp.Exporter(mdg, "adv-diff", folder_name=output_directory)

    proj_u = P1.eval_at_cell_centers(sd)

    for n, u in enumerate(sol):
        for sd, data in mdg.subdomains(return_data=True):
            # post process variables
            cell_u = proj_u @ u

            pp.set_solution_values("mass", cell_u, data, time_step_index=0)
            save.write_vtu(["mass"], time_step=n)

    save.write_pvd(range(len(sol)))


def plot_spatial_convergence(grid_sizes, l2_errors):
    """Plot the spatial convergence of the L2 error."""
    plt.plot(np.array(grid_sizes)[:, 0], l2_errors, marker="o")
    plt.xscale("log")
    plt.yscale("log")
    plt.xlabel("Grid size")
    plt.ylabel("L2 error")
    plt.title("Spatial convergence for advection-diffusion equation")
    plt.grid()
    plt.show()


def plot_temporal_convergence(timesteps, l2_errors):
    """Plot the temporal convergence of the L2 error."""
    plt.plot(np.array(timesteps), l2_errors, marker="o")
    plt.xscale("log")
    plt.yscale("log")
    plt.xlabel("Time step size")
    plt.ylabel("L2 error")
    plt.title("Temporal convergence for advection-diffusion equation")
    plt.grid()
    plt.show()


for dt in timesteps:
    for grid_size in grid_sizes:
        mdg = create_grid(grid_size, dim)

        for sd, data in mdg.subdomains(return_data=True):
            # initialize the parameters on the grid
            diff = pp.SecondOrderTensor(np.full(sd.num_cells, D))

            vel_field = np.broadcast_to(V[:, None], (3, sd.num_cells))

            param = {"vector_field": vel_field, "second_order_tensor": diff}
            pp.initialize_data(sd, data, key, param)

            # with the following steps we identify the portions of the boundary
            # to impose the boundary conditions
            left_faces = sd.face_centers[0, :] == 0
            right_faces = sd.face_centers[0, :] == 1
            bottom_faces = sd.face_centers[1, :] == 0
            top_faces = sd.face_centers[1, :] == 1

            bottom_nodes = sd.nodes[1, :] == 0
            top_nodes = sd.nodes[1, :] == 1
            left_nodes = sd.nodes[0, :] == 0
            right_nodes = sd.nodes[0, :] == 1

            # set flags for essential and natural boundary conditions
            nat_bc_flags = left_faces
            ess_bc_flags = np.logical_or(
                np.logical_or(right_nodes, left_nodes),
                np.logical_or(bottom_nodes, top_nodes),
            )

        # construct the constant local matrices
        mass = P1.assemble_mass_matrix(sd, data)
        adv = P1.assemble_adv_matrix(sd, data)

        # assemble the global constant matrix
        # fmt: off
        global_matrix_const = dt*adv + L * mass 
        # fmt: on

        # get the source term and the manufactured solution
        source, solution = manufactured_solution()

        # set natural boundary values
        nat_bc_vals = P1.assemble_nat_bc(sd, nat_bc_func, nat_bc_flags)

        # set essential boundary values
        ess_bc_vals = P1.interpolate(sd, lambda X: solution(X[0], X[1], 0.0))

        # get the degrees of freedom for u
        dof_u = sd.num_nodes

        # assemble the time-independent right-hand side
        rhs_const = np.zeros(dof_u)
        # rhs_const += source_vals

        # initialize the solution arrays
        num_steps = int(end_time / dt)
        sol = np.empty((num_steps + 1, dof_u), dtype=np.float64)
        sol_an = np.empty((num_steps + 1, dof_u), dtype=np.float64)

        # set and store initial conditions
        u = P1.interpolate(sd, lambda X: solution(X[0], X[1], 0.0))
        sol[0] = u
        sol_an[0] = u

        # set projection operator for u
        proj_u = P1.eval_at_cell_centers(sd)

        for n in range(1, num_steps + 1):
            print(f"Grid size: {grid_size}")
            print(f"Time step {n} of {num_steps}, dt = {dt}")
            # set time-dependent source term
            source_vals = P1.source_term(sd, lambda X: source(X[0], X[1], n * dt))

            B_fixed = B(u)
            # assemble the time-dependent right-hand side
            rhs_fixed = rhs_const.copy()
            rhs_fixed += dt * source_vals + mass @ B_fixed

            u_prev = u.copy()

            # L-scheme iterations
            for i in range(iter):
                # calculate the non-linear diffusion term for cell center and nodes
                diff_cell = diff_func(sd, proj_u @ u_prev)
                diff_node = diff_func(sd, u_prev)

                B_iter = mass_func(u_prev)

                # update the diffusion tensor in the data
                pp.initialize_data(
                    sd,
                    data,
                    key,
                    {"second_order_tensor": pp.SecondOrderTensor(diff_cell)},
                )

                # set iterative rhs
                rhs = rhs_fixed.copy()
                rhs += (
                    L * mass @ u_prev - mass @ B_iter
                )  # + dt * nat_bc_vals @ diff_node

                # assemble the u dependent local matrices for the current iteration
                stiff = P1.assemble_stiff_matrix(sd, data)

                # assemble the global matrix for the current iteration
                # fmt: off
                global_matrix = global_matrix_const.copy()
                global_matrix += dt * stiff
                # fmt: on

                # set up the linear system
                ls = pg.LinearSystem(global_matrix, rhs)

                # flag the essential boundary conditions
                ls.flag_ess_bc(ess_bc_flags, ess_bc_vals)

                # solve the problem
                u = ls.solve()

                # Check if we have reached convergence
                rel_err = np.sqrt(np.sum(np.power(u - u_prev, 2)))
                abs_err = np.sqrt(np.sum(np.power(u_prev, 2)))

                # Log message with error and current iteration
                print(
                    "Iteration #"
                    + str(i + 1)
                    + ", error L2 relative u: "
                    + str(rel_err)
                )

                if rel_err > abs_tol + rel_tol * abs_err:
                    u_prev = u.copy()
                else:
                    break

            # calculate the analytical solution for the current time step
            u_an = P1.interpolate(sd, lambda X: solution(X[0], X[1], n * dt))

            # store the solution
            sol[n] = u_prev
            sol_an[n] = u_an

        # calculate and store the L2 error
        l2_errors.append(P1.error_l2(sd, u, lambda X: solution(X[0], X[1], n * dt)))

        # export_data("num_sol", sol, mdg, sd)
        # export_data("ana_sol", sol_an, mdg, sd)


def calculate_convergence_order(l2_errors):
    """Calculate the convergence order based on L2 errors."""
    orders = []
    for i in range(1, len(l2_errors)):
        order = np.log(l2_errors[i - 1] / l2_errors[i]) / np.log(2)
        orders.append(order)
    print("Order of convergence:", orders)


plot_spatial_convergence(grid_sizes, l2_errors)
print("L2 errors:", l2_errors)
calculate_convergence_order(l2_errors)
# plot_temporal_convergence(timesteps, l2_errors)
