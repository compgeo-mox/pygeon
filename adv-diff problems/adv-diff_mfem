import os
import shutil
import numpy as np
import porepy as pp
import pygeon as pg
import sympy as sp
import matplotlib.pyplot as plt
import scipy.sparse as sps

"""
Solve advection-diffusion equation using Backward Euler in time,
linearized by the L-scheme, and discretized by Mixed Finite Element Method (MFEM).

PDEs:
    ∂u/∂t + ∇·q = S
    q - a u + D*∇u = 0


Time discretization (Backward Euler):
    (u^{n+1} - u^n) / Δt + ∇·q^{n+1} = S
    q^{n+1} - a u^{n+1} + D ∇u^{n+1} = 0

Variational (weak) form: find u in V such that
for all test functions φ_1, φ_2:

    ∫_Ω u^{n+1} φ_1 dΩ
    + Δt ∫_Ω ∇·q^{n+1} φ_1 dΩ
    = Δt ∫_Ω S^{n+1} φ_1 dΩ
    + ∫_Ω u^{n} φ_1 dΩ

    ∫_Ω q^n+1 φ_2 dΩ
    - ∫_Ω a · u^{n+1} φ_2 dΩ    
    - D ∫_Ω u^n+1 ∇·φ_2 dΩ
    = - D ∫_Γ u^n+1 (φ_2 · ν) dΓ

This gives the matrix equation:
    (M_u        Δt B) (u^n+1) = (ΔtS + Mu^n)
    ((A - D B^T)   M_q) (q^n+1) = (-D BC     )
"""

# Paramenter
D = 1  # Diffusion coefficient
V = np.array([1.0, 0.0, 0.0])  # Velocity vector
L = 1e-1  # L-scheme parameter, can be adjusted
inflow_rate = 10.0  # Inflow rate for the boundary condition

grid_sizes = [[3, 3]]  # [[10, 10], [20, 20], [40, 40], [80, 80], [160, 160]]
dim = [1, 1]
timesteps = [0.001]  # [0.002, 0.001, 0.0005, 0.00025, 0.000125]
num_steps = 50
iter = 50  # Number of iterations for the L-scheme linearization
# Relative and absolute tolerances for the non-linear solver
abs_tol = 1e-10
rel_tol = 1e-10

key = "mass"

l2_errors = []

P0 = pg.PwConstants(key)
RT0 = pg.RT0(key)


def manufactured_solution():
    """Manufactured solution for the advection-diffusion equation."""

    # Define variables and parameters
    x, y, t = sp.symbols("x y t")
    Vx, Vy, D = sp.symbols("Vx Vy D")

    # Define manufactured solution u
    u = t * x * y * (1 - x) * (1 - y)

    # Compute partial derivatives
    ut = sp.diff(u, t)
    ux = sp.diff(u, x)
    uy = sp.diff(u, y)

    # Directional flux terms qx and qy
    q_x = Vx * u - D * ux
    q_y = Vy * u - D * uy

    # Compute the divergence of q
    q_div = sp.diff(q_x, x) + sp.diff(q_y, y)

    # Source term f from PDE residual
    f = ut - q_div

    # Set the velocity field values
    f = f.subs({Vx: 1.0, Vy: 0.0, D: 1.0})

    # Simplify the source term
    f_simplified = sp.simplify(f)

    # Create lambdified functions for source term and solution
    source = sp.lambdify((x, y, t), f_simplified, "numpy")
    solution = sp.lambdify((x, y, t), u, "numpy")

    return source, solution


def nat_bc_func(x):
    """Natural boundary condition function."""
    return inflow_rate


def ess_bc_func(x):
    """Essential boundary condition function."""
    return 0.0


def source_term(x):
    """Source term function."""
    return 0.0


def init_sol_func(x):
    """Initial condition function."""
    return 0.0


def diff_func(sd, u):
    """Compute the non-linear diffusion term D(u) on grid."""
    return u**2


def vel_func(sd, u):
    """Compute the non-linear advection term A(u) on grid.
    Note: Not used"""
    return 1.0 * np.ones(sd.num_cells)


def create_grid(grid_size, dim):
    """Create a structured triangle grid for the problem."""
    sd = pp.StructuredTriangleGrid(grid_size, dim)

    # convert the grid into a mixed-dimensional grid
    mdg = pg.as_mdg(sd)

    # Convert to a pygeon grid
    pg.convert_from_pp(sd)
    sd.compute_geometry()

    return mdg


def export_data(name, sol, mdg, sd):
    """Export the solution data to pvd-file."""
    output_directory = os.path.join(os.path.dirname(__file__), "adv-diff " + name)
    # Delete the output directory, if it exisis
    if os.path.exists(output_directory):
        shutil.rmtree(output_directory)

    save = pp.Exporter(mdg, "adv-diff", folder_name=output_directory)

    proj_u = P0.eval_at_cell_centers(sd)

    for n, u in enumerate(sol):
        for sd, data in mdg.subdomains(return_data=True):
            # post process variables
            cell_u = proj_u @ u

            pp.set_solution_values("mass", cell_u, data, time_step_index=0)
            save.write_vtu(["mass"], time_step=n)

    save.write_pvd(range(len(sol)))


def plot_spatial_convergence(grid_sizes, l2_errors):
    """Plot the spatial convergence of the L2 error."""
    plt.plot(np.array(grid_sizes)[:, 0], l2_errors, marker="o")
    plt.xscale("log")
    plt.yscale("log")
    plt.xlabel("Grid size")
    plt.ylabel("L2 error")
    plt.title("Spatial convergence for advection-diffusion equation")
    plt.grid()
    plt.show()


def plot_temporal_convergence(timesteps, l2_errors):
    """Plot the temporal convergence of the L2 error."""
    plt.plot(np.array(timesteps), l2_errors, marker="o")
    plt.xlabel("Time step size")
    plt.ylabel("L2 error")
    plt.title("Temporal convergence for advection-diffusion equation")
    plt.grid()
    plt.show()


for dt in timesteps:
    for grid_size in grid_sizes:
        mdg = create_grid(grid_size, dim)

        for sd, data in mdg.subdomains(return_data=True):
            # initialize the parameters on the grid
            diff = pp.SecondOrderTensor(np.full(sd.num_cells, D))

            vel_field = np.broadcast_to(V[:, None], (3, sd.num_cells))

            param = {"vector_field": vel_field, "second_order_tensor": diff}
            pp.initialize_data(sd, data, key, param)

            # with the following steps we identify the portions of the boundary
            # to impose the boundary conditions
            left_faces = sd.face_centers[0, :] == 0
            right_faces = sd.face_centers[0, :] == 1
            bottom_faces = sd.face_centers[1, :] == 0
            top_faces = sd.face_centers[1, :] == 1

            bottom_nodes = sd.nodes[1, :] == 0
            top_nodes = sd.nodes[1, :] == 1
            left_nodes = sd.nodes[0, :] == 0
            right_nodes = sd.nodes[0, :] == 1

            # set flags for essential and natural boundary conditions
            nat_bc_flags = left_faces
            ess_bc_flags = np.logical_or(
                np.logical_or(right_nodes, left_nodes),
                np.logical_or(bottom_nodes, top_nodes),
            )

        # construct the constant local matrices
        mass_u = P0.assemble_mass_matrix(sd, data)
        mass_q = RT0.assemble_mass_matrix(sd, data)
        div = dt * pg.cell_mass(mdg) @ pg.div(mdg)
        A = -vel_field @ mass_u
        div_transpose = diff @ div.T

        # assemble the saddle point problem
        # fmt: off
        spp = sps.block_array([[mass_u,               div],
                               [A + div_transpose, mass_q]], format="csc")
        # fmt: on

        # get the source term and the manufactured solution
        source, solution = manufactured_solution()

        # get the degrees of freedom for u
        dof_u, dof_q = div.shape

        # set natural boundary values
        nat_bc_vals = RT0.assemble_nat_bc(sd, nat_bc_func, nat_bc_flags)

        # set essential boundary values
        ess_bc_vals = P0.interpolate(sd, lambda X: solution(X[0], X[1], 0.0))

        # assemble the time-independent right-hand side
        rhs_const = np.zeros(dof_u + dof_q)
        # rhs_const[dof_q:] += -D * nat_bc_vals

        # initialize the solution arrays
        sol = np.empty((num_steps + 1, dof_u), dtype=np.float64)
        sol_an = np.empty((num_steps + 1, dof_u), dtype=np.float64)

        # set and store initial conditions
        u = P0.interpolate(sd, lambda X: solution(X[0], X[1], 0.0))
        sol[0] = u
        sol_an[0] = u

        # set projection operator for u
        proj_u = P0.eval_at_cell_centers(sd)

        for n in range(1, num_steps + 1):
            rhs = rhs_const.copy()
            # assemble the time-dependent right-hand side
            rhs[:dof_q] = (
                dt * P0.source_term(sd, lambda X: source(X[0], X[1], n * dt))
                + mass_u @ u
            )

            # set up the linear system
            ls = pg.LinearSystem(spp, rhs)

            # flag the essential boundary conditions
            ls.flag_ess_bc(ess_bc_flags, ess_bc_vals)

            # solve the problem
            u = ls.solve()

            # calculate the manufactured solution
            u_an = P0.interpolate(sd, lambda X: solution(X[0], X[1], n * dt))

            # store the solutions
            sol[n] = u
            sol_an[n] = u_an

        # calculate and store the L2 error
        l2_errors.append(P0.error_l2(sd, u, lambda X: solution(X[0], X[1], n * dt)))

        # export_data("num_sol", sol, mdg, sd)
        # export_data("ana_sol", sol_an, mdg, sd)


# plot_spatial_convergence(grid_sizes, l2_errors)
plot_temporal_convergence(timesteps, l2_errors)
print("L2 errors:", l2_errors)
