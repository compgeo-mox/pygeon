"""Module contains Nedelec unit tests."""

import unittest

import numpy as np
import porepy as pp

import pygeon as pg  # type: ignore[import-untyped]


class NedelecTest(unittest.TestCase):
    def test_nedelec0(self):
        N, dim = 1, 3
        sd = pp.StructuredTetrahedralGrid([N] * dim, [1] * dim)
        pg.convert_from_pp(sd)
        sd.compute_geometry()

        discr = pg.Nedelec0()

        # Check that the number of degrees of freedom is correct
        self.assertEqual(discr.ndof(sd), 19)

        M = discr.assemble_mass_matrix(sd)

        # fmt: off
        M_known_data = np.array(
        [ 0.08333333,  0.04166667,  0.04166667,  0.        ,  0.        ,
         0.        ,  0.04166667,  0.08333333,  0.04166667,  0.        ,
         0.        ,  0.        ,  0.04166667,  0.04166667,  0.08333333,
         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,
         0.        ,  0.15      ,  0.        ,  0.05      , -0.03333333,
        -0.00833333, -0.00833333, -0.08333333, -0.00833333, -0.04166667,
         0.        ,  0.18333333,  0.075     ,  0.03333333,  0.03333333,
         0.00833333,  0.00833333, -0.08333333, -0.04166667,  0.        ,
         0.        ,  0.        ,  0.05      ,  0.15      ,  0.        ,
        -0.03333333,  0.00833333, -0.04166667, -0.00833333, -0.08333333,
        -0.00833333,  0.075     ,  0.        ,  0.18333333,  0.03333333,
        -0.00833333, -0.04166667,  0.03333333,  0.00833333, -0.08333333,
        -0.03333333,  0.03333333, -0.03333333,  0.03333333,  0.16666667,
         0.01666667,  0.        ,  0.03333333,  0.        , -0.03333333,
         0.01666667,  0.03333333, -0.03333333, -0.00833333,  0.03333333,
         0.01666667,  0.08333333,  0.03333333, -0.00833333,  0.        ,
         0.        ,  0.        , -0.00833333,  0.00833333,  0.        ,
         0.08333333, -0.00833333,  0.00833333, -0.08333333,  0.00833333,
        -0.04166667,  0.03333333,  0.03333333, -0.00833333,  0.18333333,
         0.        ,  0.075     ,  0.00833333, -0.00833333,  0.        ,
         0.08333333,  0.00833333,  0.        , -0.00833333,  0.        ,
         0.        , -0.00833333, -0.08333333, -0.04166667, -0.03333333,
        -0.00833333,  0.        ,  0.00833333,  0.15      ,  0.        ,
         0.05      ,  0.        ,  0.        ,  0.        ,  0.        ,
         0.08333333,  0.        ,  0.04166667,  0.04166667, -0.00833333,
         0.03333333,  0.01666667,  0.08333333,  0.03333333, -0.00833333,
        -0.04166667, -0.08333333,  0.00833333,  0.03333333,  0.00833333,
         0.075     ,  0.03333333,  0.18333333,  0.        , -0.04166667,
        -0.00833333, -0.08333333, -0.03333333, -0.00833333,  0.05      ,
         0.        , -0.00833333,  0.        ,  0.15      ,  0.        ,
         0.        ,  0.        ,  0.        ,  0.04166667,  0.        ,
         0.08333333,  0.04166667,  0.        ,  0.        ,  0.04166667,
         0.        ,  0.04166667,  0.08333333]
        )

        M_known_indices = np.array(
        [ 0,  1,  2,  3,  5,  9,  0,  1,  2,  3,  5,  9,  0,  1,  2,  3,  5,
         9,  0,  1,  2,  3,  4,  5,  7,  8,  9, 10, 12, 15,  3,  4,  6,  7,
         8, 10, 11, 12, 16,  0,  1,  2,  3,  5,  6,  7,  9, 10, 14, 15, 16,
         4,  5,  6,  7, 11, 12, 14, 15, 16,  3,  4,  5,  6,  7,  8,  9, 10,
        11, 12, 14, 15, 16,  3,  4,  7,  8, 10, 12,  0,  1,  2,  3,  5,  7,
         9, 10, 15,  3,  4,  5,  7,  8,  9, 10, 12, 15,  4,  6,  7, 11, 12,
        13, 16, 17, 18,  3,  4,  6,  7,  8, 10, 11, 12, 13, 16, 17, 18, 11,
        12, 13, 16, 17, 18,  5,  6,  7, 14, 15, 16,  3,  5,  6,  7,  9, 10,
        14, 15, 16,  4,  5,  6,  7, 11, 12, 13, 14, 15, 16, 17, 18, 11, 12,
        13, 16, 17, 18, 11, 12, 13, 16, 17, 18]
        )

        M_known_indptr = np.array(
        [  0,   6,  12,  18,  30,  39,  51,  60,  73,  79,  88,  97, 106,
        118, 124, 130, 139, 151, 157, 163]
        )
        # fmt: on

        M.sum_duplicates()
        self.assertTrue(np.allclose(M.data, M_known_data))
        self.assertTrue(np.allclose(M.indptr, M_known_indptr))
        self.assertTrue(np.allclose(M.indices, M_known_indices))

        D = discr.assemble_diff_matrix(sd)

        # fmt: off
        D_known_data = np.array(
        [ 1,  1, -1,  1, -1, -1,  1,  1,  1,  1, -1,  1,  1,  1, -1,  1,  1,
        -1, -1,  1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1, -1, -1,  1,  1,
         1,  1,  1, -1,  1, -1, -1,  1,  1,  1,  1, -1,  1,  1,  1,  1,  1,
        -1,  1,  1]
        )

        D_known_indices = np.array(
        [ 0,  1,  0,  2,  1,  2,  0,  3,  4,  5,  3,  6,  7,  1,  4,  8,  9,
         6,  8, 10,  5,  7,  9, 10,  3, 11,  2,  4, 12,  5, 11, 12,  6, 13,
        14,  7, 11, 13, 15, 14, 15,  8, 16,  9, 12, 16, 10, 13, 16, 17, 14,
        17, 15, 17]
        )

        D_known_indptr = np.array(
        [ 0,  2,  4,  6, 10, 13, 17, 20, 24, 26, 29, 32, 35, 39, 41, 43, 46,
        50, 52, 54]
        )
        # fmt: on

        self.assertTrue(np.allclose(D.data, D_known_data))
        self.assertTrue(np.allclose(D.indptr, D_known_indptr))
        self.assertTrue(np.allclose(D.indices, D_known_indices))

        self.assertRaises(
            NotImplementedError,
            discr.assemble_nat_bc,
            sd,
            lambda _: np.zeros(1),
            np.zeros(1),
        )

        self.assertTrue(discr.get_range_discr_class(dim) is pg.RT0)

    def test_nedelec0_lumped(self):
        dim = 3
        N = 1

        sd = pp.StructuredTetrahedralGrid([N] * dim, [1] * dim)
        pg.convert_from_pp(sd)
        sd.compute_geometry()

        discr = pg.Nedelec0()

        Ml = discr.assemble_lumped_matrix(sd)
        M = discr.assemble_mass_matrix(sd)

        ones = np.ones(discr.ndof(sd))
        self.assertTrue(np.allclose(Ml @ ones, M @ ones))

    def test_nedelec1(self):
        N, dim = 1, 3
        sd = pp.StructuredTetrahedralGrid([N] * dim, [1] * dim)
        pg.convert_from_pp(sd)
        sd.compute_geometry()

        discr = pg.Nedelec1()

        # Check that the number of degrees of freedom is correct
        self.assertEqual(discr.ndof(sd), 19 * 2)

        M = discr.assemble_lumped_matrix(sd)

        # fmt: off
        M_known_data = np.array(
        [ 0.04166667,  0.        ,  0.        ,  0.        ,  0.04166667,
         0.        ,  0.        ,  0.        ,  0.04166667,  0.20833333,
        -0.04166667,  0.04166667, -0.125     , -0.04166667, -0.04166667,
         0.16666667,  0.04166667, -0.04166667,  0.04166667,  0.20833333,
        -0.04166667, -0.125     , -0.04166667,  0.04166667, -0.04166667,
         0.16666667, -0.04166667, -0.125     , -0.04166667, -0.125     ,
        -0.04166667,  0.25      ,  0.08333333,  0.        , -0.04166667,
         0.125     , -0.08333333, -0.04166667, -0.04166667,  0.        ,
        -0.08333333,  0.16666667,  0.04166667,  0.125     , -0.04166667,
        -0.04166667, -0.08333333, -0.04166667,  0.125     , -0.04166667,
         0.04166667, -0.04166667, -0.04166667, -0.04166667,  0.125     ,
         0.08333333,  0.        , -0.04166667,  0.        ,  0.16666667,
         0.04166667, -0.08333333,  0.125     , -0.04166667,  0.04166667,
        -0.04166667, -0.04166667, -0.04166667,  0.125     , -0.04166667,
         0.125     , -0.04166667, -0.04166667, -0.04166667, -0.04166667,
         0.125     , -0.04166667,  0.125     , -0.04166667,  0.125     ,
        -0.04166667, -0.04166667, -0.04166667, -0.04166667,  0.04166667,
        -0.04166667,  0.125     , -0.08333333,  0.04166667,  0.16666667,
         0.        , -0.04166667,  0.04166667, -0.04166667,  0.125     ,
        -0.04166667,  0.04166667,  0.16666667, -0.08333333,  0.        ,
         0.25      , -0.04166667, -0.125     , -0.04166667, -0.125     ,
        -0.04166667,  0.        ,  0.08333333, -0.08333333, -0.04166667,
        -0.04166667,  0.125     , -0.04166667,  0.16666667, -0.04166667,
         0.04166667, -0.04166667, -0.04166667, -0.08333333,  0.125     ,
        -0.04166667, -0.125     , -0.04166667,  0.20833333,  0.04166667,
         0.04166667,  0.        ,  0.        , -0.04166667,  0.        ,
         0.08333333, -0.04166667,  0.04166667,  0.16666667, -0.04166667,
        -0.04166667, -0.125     ,  0.04166667, -0.04166667,  0.20833333,
         0.        ,  0.04166667,  0.        ,  0.        ,  0.        ,
         0.04166667]
        )

        M_known_indices = np.array(
        [ 0,  1,  2,  0,  1,  2,  0,  1,  2,  3,  4,  5,  7, 19,  3,  4,  6,
         7,  3,  5,  6,  7, 19,  4,  5,  6,  7,  3,  4,  5,  6,  7,  8, 10,
        22,  9, 10, 20, 22,  8,  9, 10, 22, 11, 12, 13, 23, 11, 12, 13, 23,
        27, 11, 12, 13, 14, 15, 24, 14, 15, 24, 28, 16, 17, 25, 30, 33, 16,
        17, 30, 18, 31, 35,  3,  5, 19,  9, 20, 22, 21, 24, 28,  8,  9, 10,
        20, 22, 11, 12, 23, 27, 14, 15, 21, 24, 28, 16, 25, 30, 33, 26, 29,
        31, 34, 35, 12, 23, 27, 15, 21, 24, 28, 26, 29, 31, 34, 16, 17, 25,
        30, 18, 26, 29, 31, 35, 32, 36, 37, 16, 25, 33, 26, 29, 34, 35, 18,
        26, 31, 34, 35, 32, 36, 37, 32, 36, 37]
        )

        M_known_indptr = np.array(
        [  0,   3,   6,   9,  14,  18,  23,  27,  32,  35,  39,  43,  47,
         52,  55,  58,  62,  67,  70,  73,  76,  79,  82,  87,  91,  96,
        100, 105, 108, 112, 116, 120, 125, 128, 131, 135, 140, 143, 146]
        )
        # fmt: on

        M.sum_duplicates()
        self.assertTrue(np.allclose(M.data, M_known_data))
        self.assertTrue(np.allclose(M.indptr, M_known_indptr))
        self.assertTrue(np.allclose(M.indices, M_known_indices))

        D = discr.assemble_diff_matrix(sd)

        # fmt: off
        D_known_data = np.array(
        [ 0.5,  0.5,  0.5, -0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
         0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5, -0.5, -0.5,
        -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5,
         0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,
         0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,
        -0.5, -0.5,  0.5,  0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,
         0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
         0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5, -0.5,
        -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
        -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5]
        )

        D_known_indices = np.array(
        [ 1,  0,  2,  0,  2,  1,  5,  4,  3,  0,  7,  6,  3,  9,  8,  4,  1,
        10,  8,  6, 10,  9,  7,  5, 11,  3, 12,  4,  2, 12, 11,  5, 14, 13,
         6, 15, 13, 11,  7, 15, 14, 16,  8, 16, 12,  9, 17, 16, 13, 10, 17,
        14, 17, 15,  1,  0,  2,  0,  2,  1,  5,  4,  3,  0,  7,  6,  3,  9,
         8,  4,  1, 10,  8,  6, 10,  9,  7,  5, 11,  3, 12,  4,  2, 12, 11,
         5, 14, 13,  6, 15, 13, 11,  7, 15, 14, 16,  8, 16, 12,  9, 17, 16,
        13, 10, 17, 14, 17, 15]
        )

        D_known_indptr = np.array(
        [  0,   2,   4,   6,  10,  13,  17,  20,  24,  26,  29,  32,  35,
        39,  41,  43,  46,  50,  52,  54,  56,  58,  60,  64,  67,  71,
        74,  78,  80,  83,  86,  89,  93,  95,  97, 100, 104, 106, 108]
        )
        # fmt: on

        self.assertTrue(np.allclose(D.data, D_known_data))
        self.assertTrue(np.allclose(D.indptr, D_known_indptr))
        self.assertTrue(np.allclose(D.indices, D_known_indices))

        self.assertRaises(
            NotImplementedError,
            discr.assemble_nat_bc,
            sd,
            lambda _: np.zeros(1),
            np.zeros(1),
        )

        self.assertRaises(
            NotImplementedError,
            discr.assemble_mass_matrix,
            sd,
        )

        self.assertTrue(discr.get_range_discr_class(dim) is pg.RT0)

    def test_interpolation(self):
        N, dim = 4, 3
        sd = pp.StructuredTetrahedralGrid([N] * dim, [1] * dim)
        pg.convert_from_pp(sd)
        sd.compute_geometry()

        def r_constant(x):
            return np.array([1.0, 2.0, np.pi])

        for discr in [pg.Nedelec0(), pg.Nedelec1()]:
            interp_r = discr.interpolate(sd, r_constant)
            eval_r = discr.eval_at_cell_centers(sd) @ interp_r
            eval_r = np.reshape(eval_r, (3, -1), order="F")

            known_r = np.array([r_constant(x) for x in sd.cell_centers.T]).T
            self.assertAlmostEqual(np.linalg.norm(eval_r - known_r), 0)


if __name__ == "__main__":
    unittest.main()
